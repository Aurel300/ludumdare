#!/usr/bin/env php
<?php 
/*
	Summary of this program and its intent:
	
This is an API test for the ludumdare website. It's goal is to interact with all API functionality by simulating a ludumdare.
Users will be created, an event will be created, users will post, read other users posts, post comments, like, etc.
Users will interact with the theme creation process stages, will publish games, will rate each other's games, and will observe the results.
The script will keep track of (some/much of) the data it generates, and will verify that what it sees is what it expects.
(Future) Users will maliciously interact with the API to verify that things cannot be changed (e.g. votes, theme creation) outside of the time when they are enabled to be changed.

The exact flow will be documented in the data structures that guide the process, below.

*/

const CONFIG_PATH = "../src/shrub/";
const SHRUB_PATH = "../src/shrub/src/";

# Use shrub wrapper for db access
include_once __DIR__."/".CONFIG_PATH."config.php";
require_once __DIR__."/".SHRUB_PATH."constants.php";
require_once __DIR__."/".SHRUB_PATH."core/db.php";
require_once __DIR__."/".SHRUB_PATH."node/node.php";
require_once __DIR__."/".SHRUB_PATH."user/user.php";


if ( count($argv) < 3  || ($argv[2] != "actions" && $argv[2] != "minutes")) {
	print "LudumDare Event simulator. Quick summary:\n";
	print "  Creates a new event, and simulates a number of users interacting with it.\n";
	print "  This is an API test, and does not aim to test the website's rendering.\n";
	print "  (It does however provide a good way to generate data to test the website)\n";
	print "\n";
	print "Run simulation for 1000 actions per stage: ".$argv[0]." 1000 actions\n";
	print "Run simulation for 5 minutes per stage: ".$argv[0]." 5 minutes\n";
	print "\n";
	exit(1);
}


$runminutes = null;
$runactions = null;
if($argv[2] == "minutes")
{
	$runminutes = intval($argv[1]);
} 
else 
{
	$runactions = intval($argv[1]);
}


////////////////////////////////
// Some global settings

$apibase = "http://api.ludumdare.org/";
$usercount = 40;
$keepallposts = true;
$keeppostcount = 100; // Number of posts per user to keep, when keep all posts is false (which it should be for high user counts or long runtimes / stress environments.)
$verbose = true; // Display all of the details about what's going on?
$verboselog = true; // Keep all details about what's going on in a log.
$useprevioususers = false; // (not implemented) Load the set of users from the previous test event, instead of creating new users.

$errorcount = 0;

function TimeString()
{
  $d = new DateTime();
  return $d->format("Y-m-d H:i:s");
}

function ReportError($text)
{
	global $errorcount;
	$errorcount++;
	print("[" . TimeString() . "] Error: " . $text . "\n");
}
function Verbose($text)
{
	print("[" . TimeString() . "] Verbose: " . $text . "\n");
}



/*
	Stages definition:
Each stage is a hashtable with a number of properties that are used to determine the behavior in that stage.
Properties:
	Name => Name to display for the stage
	Phases => if present, number indicating how many phases there are to the stage (otherwise just one)
	MaxMinutes => if present, override the time for each phase in this stage to avoid spending a lot of time on it.
	MaxEventsPerUser => if present, impose a hard limit on events per user for each phase in this stage to avoid spending a lot of time on this section.
	StageStart => Function that is called when the stage starts
	StageEnd => Function that is called when the stage ends
	PhaseStart => Function to be called when a phase starts
	PhaseEnd => Function to be called when a phase ends
	
	Always => List of functions (actions) to be called by all simulated users in this phase
	LowChance => List of functions (actions) to be called by a few (at least one, but less than half) of the simulated users in this phase. Each function gets its own list of users
	HighChance => list of functions (actions) to be called by most (not all, but at least half) of the simulated users in this phase. Each function gets its own list of users
	
	UserVerify => Function that is called arbitrarily to ask the system to verify that the data it receives from the website for a specific user is consistent with what it expects.
	
About start/end functions:
	Stage start and end have no argument
	Phase start and end are passed the current phase index as an argument.
	
About actions:
	The action function is always called to ask a specific user to take action.
	The action function is passed a user array, and the phase index.
	if the action function returns false, it will not be called again for that user in that phase. Otherwise it may be called multiple times.
	
About reporting errors:
	TBD
	
*/
$stages = array(
	// First stage, create users and generate the event
	array(
		"Name" => "Setup",
		"StageStart" => 'SetupEvent',
		"MaxMinutes" => 1,
		"MaxEventsPerUser" => 15,
		"LowChance" => array('PostImIn', 'CommentOnPost') // Early "I'm In" posts
	),
	// Second stage, Theme voting
	array(
		"Name" => "Theme Voting",
		"Phases" => 7, // Theme suggestion + theme slaughter + 4 rounds of voting + theme selection
		"MaxMinutes" => 1, // This is per phase
		"MaxEventsPerUser" => 200,
		"PhaseStart" => 'SetupThemePhase',
		"HighChance" => 'UserVoteOnTheme',
		"LowChance" => array('PostImIn', 'CommentOnPost')  // More various "I'm In" posts will trickle in
	),
	// Third stage, LD Starts!
	array(
		"Name" => "Compo Running",
		"StageStart" => 'StartCompo',
		"HighChance" => array('CompoPostUpdate', 'CompoEditGame', 'CommentOnPost'),
		"LowChance" => array('CommentOnGame', 'CompoPublishGame', 'CommentUnlike')
	),
	// Fourth stage, Submission deadline
	array(
		"Name" => "Compo Submission Period",
		"StageStart" => 'SetupSubmission',
		"MaxMinutes" => 2,
		"MaxEventsPerUser" => 20,
		"HighChance" => array('CommentOnGame', 'CompoPublishGame'),
		"LowChance" => array('CompoPostUpdate', 'CompoEditGame', 'CommentOnPost', 'CommentUnlike'),
	),
	// Fifth stage, Voting
	array(
		"Name" => "Compo Voting",
		"StageStart" => 'SetupVoting',
		"MaxEventsPerUser" => 300,
		"HighChance" => array('CommentOnGame', 'VoteOnGame'),
		"LowChance" => array('CommentOnPost', 'CompoEditGame', 'CompoPostUpdate', 'CommentUnlike')
	),
	// Sixth stage - Closed / resuts
	array(
		"Name" => "Compo Results",
		"StageStart" => 'EndCompo',
		"LowChance" => array('CommentOnGame', 'CommentOnPost', 'CompoEditGame', 'CompoPostUpdate', 'CommentUnlike', 'CompoPostResults')
	)
);


$event_admin_user = null;
$event_users = array();


// Prepare the event. Create an admin superuser. Create all the compo users. Create the new LudumDare event. Publish the event node.
// Some of this has to be done through the database directly (finding the email verification links, and creating the ludumdare event and setting it up)
// We'll also use some data from the database to make the naming a bit more friendly.
function SetupEvent()
{
	global $event_admin_user, $event_users;
	
	$event_admin_user = User_Create();
	
	
	exit(0);
}

// Set up for each of the phases of the theme selection, in sequence.
function SetupThemePhase($phase)
{
}

// The compo has now started, the theme voting is now locked and a theme is selected. The users will be sure to mention the theme in some of their posts.
function StartCompo()
{
}

// The compo has now stopped and will only accept submissions for a limited amount of time. Configure the event to this mode.
function SetupSubmission()
{
}

// Submission is over, and now the voting period begins
function SetupVoting()
{
}

// Voting is over, close out the compo.
function EndCompo()
{
}

// User should discover and interact with the available options in the current theme voting phase.
function UserVoteOnTheme($user, $phase)
{
	return false;
}


// Post a very simple "I'm In" post. Only do this once per event.
function PostImIn($user, $phase)
{
	return false;
}

// Find a recent post in the feed, and post a comment - and optionally give it or one of its comments a like.
function CommentOnPost($user, $phase)
{
	return false;
}
// Find a game through one of the game lists, and give it a comment, and optionally give it or one of its comments a like.
function CommentOnGame($user, $phase)
{
	return false;
}

// Remove a like from some post/comment/game that was liked previously. The simulated user revisits the node and comments, and removes the like.
function CommentUnlike($user, $phase)
{
	return false;
}

// Generate and post a new item to the compo feed
function CompoPostUpdate($user, $phase)
{
	return false;
}

// And this is the part of the game where some users wish to parade their stats into the news feed, or complain about PoV :)
function CompoPostResults($user, $phase)
{
	return false;
}

// Modify the record for the current user's game and submit an update.
function CompoEditGame($user, $phase)
{
	return false;
}
// Can only be called once. If the game is not published, publish it.
function CompoPublishGame($user, $phase)
{
	return false;
}

////
//// Code to drive the stage progression based on the $stages variable defined above.
////
$stagecount = count($stages);


for($curStage = 0; $curStage < $stagecount; $curStage++)
{
	$stage = $stages[$curStage];
	Verbose("Starting stage " . $curStage . " - " . $stage["Name"]);

	// Start stage function
	if(key_exists("StageStart",$stage)) { $stage["StageStart"](); }

	$phasecount = 1;
	$hasPhases = false;
	if(key_exists("Phases", $stage)) { 
		$hasPhases = true;
		$phasecount = $stage["Phases"];
	}

	for($phase = 0; $phase < $phasecount; $phase++)
	{
		if($hasPhases && key_exists("PhaseStart",$stage)) { $stage["PhaseStart"]($phase); }

		PrepareStageActions($stage, $phase);

		// Determine proper action limiting mechanism
		if($runminutes)
		{
			// Use temporal limiting
			$minutes = $runminutes;
			if($stage["MaxMinutes"])
			{
				$minutes = Math.min($minutes, $stage["MaxMinutes"]);
			}
			$end = (new DateTime()).Add(new DateInterval("PT".$minutes."M"));
			
			while($end > new DateTime())
			{
				ExecuteStageAction($stage, $phase);
			}
		}
		else
		{
			// Use event count limiting
			for($action = 0; $action < $runactions; $action++)
			{
				ExecuteStageAction($stage, $phase);
			}
		}
		
		// Ensure promised conditions about mandatory actions hold
		CompleteMandatoryStageActions($stage, $phase);

		if($hasPhases && key_exists("PhaseEnd",$stage)) { $stage["PhaseEnd"]($phase); }

	}

	// End stage function
	if(key_exists("StageEnd",$stage)) { $stage["StageEnd"](); }
  
}

function PrepareStageActions($stage, $phase)
{

}

function ExecuteStageAction($stage, $phase)
{
	usleep(1000); // Delay 1ms
}

function CompleteMandatoryStageActions($stage, $phase)
{

}


////
//// Common functions to assist in doing normal tasks in the site
////

function User_Create()
{
	$username = GenerateRandomUsername();
	$password = GenerateRandomPassword();
	
	// Construct a user object
	$user = [
		"username" => $username,
		"password" => $password,
		"cookies" => array(),
		
		// Further info for tracking data this user has posted and interacted with.
		"posts" => array(),
		"publishedgame" => "false"
	];
	
	// Determine if username is in use
	for($i = 0; $i < 20; $i++)
	{
		if(ApiUserHave($username))
		{
			// Username is in use, pick another
			$username = GenerateRandomUsername();
			$user["username"] = $username;
		}
		else
		{
			break;
		}
	}
	
	// API request to create user
	$email = $username . "@ludumdare.org";
	
	$mailsent = ApiUserCreate($email, $user);
	if(!$mailsent)
	{
		Verbose("Warning: User create didn't send mail. It's not strictly necessary to catch mail for this, but you probably don't have the mail catcher running.");
	}
	
	// Dig out the email auth token from the database and activate the user
	$userdata = user_GetByMail($email);
	$id = $userdata["id"];
	$key = $userdata["auth_key"];
	
	if(!ApiUserActivate($user, $id, $key))
	{
		ReportError("Error while creating user.");
		return null;
	}
	
	$user["id"] = $id;
	
	// Login the user
	if(!ApiUserLogin($user))
	{
		ReportError("Unable to login new user.");
		return null;	
	}
	
	return $user;
}




// Does the site have this username already?
function ApiUserHave($username)
{
	$value = LdApi::Post("vx/user/have","name=".$username);
	if($value != null)
	{
		return !($value["available"]);
	}
	return false;
}

// Create a new user (by email address)
function ApiUserCreate($email, &$user)
{
	$value = LdApi::Post("vx/user/create","mail=".$email, $user);
	if($value != null)
	{
		return $value["sent"];
	}
	return false;
}

function ApiUserActivate(&$user, $id, $auth_key)
{
	$name = $user["username"];
	$pw = $user["password"];
	
	$postString = "id=".$id."&key=".$auth_key."&name=".$name."&pw=".$pw;
	$value = LdApi::Post("vx/user/activate",$postString,$user);
	
	if($value != null)
	{
		return $value["response_httpcode"] == "201";
	}
	return false;
}

function ApiUserLogin(&$user)
{
	$login = $user["username"];
	$pw = $user["password"];
	
	$value = LdApi::Post("vx/user/login", "login=".$login."&pw=".$pw, $user);
	
	if($value != null)
	{
		return $value["response_httpcode"] == "200"; 
	}
	return $false;
}

////
//// Low level helper / generation code
////

function GenerateRandomUsername()
{
  $length = random_int(2, 10);
  return bin2hex(random_bytes($length));
}

function GenerateRandomPassword()
{
  $length = random_int(5, 10);
  return bin2hex(random_bytes($length));
}

// Future: something much more meaningful. Also figure out how to include image uploads, links, other fun feathres.
function GenerateRandomPostText($minWords = 10, $maxWords = 200)
{
	$words = random_int($minWords, $maxWords);
	$allwords = array();
	for($i=0;$i<$words;$i++)
	{
		$wordlength = random_int(1,5);
		$word = bin2hex(random_bytes($wordlength));
		$allwords[] = $word;
	}
	return implode(" ",$allwords);
}

////
//// Low level API interface code
////

class LdApi
{
	static $debug_api = true;

	static function SetRequestUser($curl, &$user)
	{
		if($user != null)
		{
			// Generate cookie string for user and set it.
			$cookies = [];
			foreach($user["cookies"] as $c => $v)
			{
				$cookies[] = $c."=".$v;
			}
			$cookiestring = implode("; ", $cookies);
			curl_setopt($curl, CURLOPT_COOKIE, $cookiestring);
			if($cookiestring != "")
			{
				Verbose("Sending Cookie: ".$cookiestring);
			}
		}
	}
	static function UpdateUserCookie($headers, &$user)
	{
		if($user != null)
		{
			$lines = explode("\r\n", $headers);
			foreach($lines as $v)
			{
				$parts = explode(": ",$v, 2);
				if($parts[0] == "Set-Cookie")
				{
					Verbose("Receive Set-Cookie: ".$parts[1]);
					$c = explode(";", $parts[1]);
					$cookiedata = explode("=",$c[0],2);
					// interpret "=deleted" as the condition to delete a cookie, as the code to check the expires time is annoying in php.
					if($cookiedata[1] == "deleted")
					{
						unset($user["cookies"][$cookiedata[0]]);
					}
					else
					{
						$user["cookies"][$cookiedata[0]] = $cookiedata[1];
					}
				}			
			}
		}
	}
	static function ForUser(&$user)
	{
		if($user != null)
		{
			return " for user " . $user["username"];
		}
		return "";
	}
  
	public static function Get($url, &$user = NULL, $report_error=true)
	{
		global $apibase;
		$outputObject = NULL;
		$url = $apibase . $url;
		if(LdApi::$debug_api)
		{
			Verbose("GET '".$url."'".LdApi::ForUser($user));
		}
		
		$c = curl_init($url);
		
		curl_setopt($c, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($c, CURLOPT_HTTPGET, true);
		
		LdApi::SetRequestUser($c, $user);
		
		$result = curl_exec($c);
		$success = !($result === false);
		if($success)
		{
			$outputObject = json_decode($result, true);
			$httpcode = curl_getinfo($c, CURLINFO_HTTP_CODE);
			$outputObject["response_httpcode"] = $httpcode;			
			LdApi::UpdateUserCookie($c, $user);
		}
		if(!$success && $report_error)
		{
			ReportError("Error getting '".$url ."'". LdApi::ForUser($user). " - " . curl_error($c));
		}
		
		if(LdApi::$debug_api)
		{
			Verbose("Response '" . $result . "'");
		}
		curl_close($c);
		
		return $outputObject;
	}
	public static function Post($url, $postdata, &$user = NULL)
	{
		global $apibase;

		$outputObject = NULL;
		$url = $apibase . $url;		

		if(LdApi::$debug_api)
		{
			Verbose("POST '".$url."' with data '".$postdata."'".LdApi::ForUser($user));
		}
		
		$c = curl_init($url);
		
		curl_setopt($c, CURLOPT_HEADER, true);
		curl_setopt($c, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($c, CURLOPT_POST, true);
		curl_setopt($c, CURLOPT_POSTFIELDS, $postdata);
		
		LdApi::SetRequestUser($c, $user);
		
		$content = "";
		$result = curl_exec($c);
		$success = !($result === false);
		if($success)
		{
			$parts = explode("\r\n\r\n",$result);
			$headers = $parts[0];
			$content = $parts[1];
		
			$outputObject = json_decode($content, true);
			$httpcode = curl_getinfo($c, CURLINFO_HTTP_CODE);
			$outputObject["response_httpcode"] = $httpcode;
			
			LdApi::UpdateUserCookie($headers, $user);
		}
		if(!$success && $report_error)
		{
			ReportError("Error getting '".$url ."'". LdApi::ForUser($user) . " - " . curl_error($c));
		}
		if(LdApi::$debug_api)
		{
			Verbose("Response '" . $content . "'");
		}
		curl_close($c);
		return $outputObject;	
	
	}
}



exit(0);