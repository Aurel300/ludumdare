#!/usr/bin/env php
<?php 
/*
	Summary of this program and its intent:
	
This is an API test for the ludumdare website. It's goal is to interact with all API functionality by simulating a ludumdare.
Users will be created, an event will be created, users will post, read other users posts, post comments, like, etc.
Users will interact with the theme creation process stages, will publish games, will rate each other's games, and will observe the results.
The script will keep track of (some/much of) the data it generates, and will verify that what it sees is what it expects.
(Future) Users will maliciously interact with the API to verify that things cannot be changed (e.g. votes, theme creation) outside of the time when they are enabled to be changed.

The exact flow will be documented in the data structures that guide the process, below.

*/

const CONFIG_PATH = "../src/shrub/";
const SHRUB_PATH = "../src/shrub/src/";

# Use shrub wrapper for db access
include_once __DIR__."/".CONFIG_PATH."config.php";
require_once __DIR__."/".SHRUB_PATH."constants.php";
require_once __DIR__."/".SHRUB_PATH."core/db.php";
require_once __DIR__."/".SHRUB_PATH."node/node.php";
require_once __DIR__."/".SHRUB_PATH."user/user.php";
require_once __DIR__."/".SHRUB_PATH."theme/theme.php";


if ( count($argv) < 3  || ($argv[2] != "actions" && $argv[2] != "minutes")) {
	print "LudumDare Event simulator. Quick summary:\n";
	print "  Creates a new event, and simulates a number of users interacting with it.\n";
	print "  This is an API test, and does not aim to test the website's rendering.\n";
	print "  (It does however provide a good way to generate data to test the website)\n";
	print "\n";
	print "Run simulation for 1000 actions per stage: ".$argv[0]." 1000 actions\n";
	print "Run simulation for 5 minutes per stage: ".$argv[0]." 5 minutes\n";
	print "\n";
	exit(1);
}


$runminutes = null;
$runactions = null;
if($argv[2] == "minutes")
{
	$runminutes = intval($argv[1]);
} 
else 
{
	$runactions = intval($argv[1]);
}


////////////////////////////////
// Some global settings

$enable_file_logs = true;
$logbase = "/tmp/ld_event"; // Logs and scratch data will be put in /tmp
$eventbase = "ld_event"; // Put event related files in current directory
$htmlbase = "ld_event"; // Put html report in current directory.
// Generate 3 kinds of log. 
//   <name>.<eventIndex>.event (Event information, user/password list)
//   <name>.<eventIndex>.log (Full Detail Verbose log)
//   <name>.<eventIndex>.err (Summary log and errors)

$apibase = "http://api.ludumdare.org/";
$usercount = 40; // Something like 40-50 is good for reasonable size tests.
$keepallposts = true;
$keeppostcount = 100; // Number of posts per user to keep, when keep all posts is false (which it should be for high user counts or long runtimes / stress environments.)
$verbose = true; // Display all of the details about what's going on?
$verboselog = true; // Keep all details about what's going on in a log.
$useprevioususers = true; // Load the set of users from the previous test event, instead of creating new users.
$usewikitext = true;

define("TOP_STATS",10); // keep top 10 stats

$errorcount = 0;

function TimeString()
{
  $d = new DateTime();
  return $d->format("Y-m-d H:i:s");
}

function ReportError($text)
{
	global $errorcount;
	$errorcount++;	
	$text = "[" . TimeString() . "] Error: " . $text . "\n";
	
	LdApi::PrintLastRequestResponse();
	
	print( "\x1b[1;31m" . $text . "\x1b[m"); // Draw with intense red color
	LogFull($text);
	LogErr($text);
}
function Verbose($text)
{
	$text = "[" . TimeString() . "] Verbose: " . $text . "\n";
	print($text);
	LogFull($text);
}
function VerboseHidden($text)
{
	$text = "[" . TimeString() . "] Verbose: " . $text . "\n";
	LogFull($text);
}

function VerboseAction($text)
{
	$text = "[" . TimeString() . "] Verbose: " . $text . "\n";
	print( "\x1b[1;34m" . $text . "\x1b[m"); // Draw in blue with intensity
	LogFull($text);
}
function Message($text)
{
	$text = "[" . TimeString() . "] " . $text . "\n";
	print( "\x1b[1m" . $text . "\x1b[m"); // Draw with greater intensity.
	LogFull($text);
	LogErr($text);
}

function LogExec($execAction)
{
	exec($execAction, $results);
	Verbose("Exec '$execAction':\n".implode("\n",$results));
}

function RunMagic()
{
	Verbose("Kickoff cron magic.php task to update necessary values in the db.");
	exec("php ~/www/private/magic.php");
}


$flogfull = null;
$flogerr = null;

function LogFull($text)
{
	global $flogfull;
	if($flogfull != null)
	{
		fwrite($flogfull, $text);
		fflush($flogfull);
	}
}
function LogErr($text)
{
	global $flogerr;
	if($flogerr != null)
	{
		fwrite($flogerr, $text);
		fflush($flogerr);
	}
}

function OpenLogs($index)
{
	global $logbase;
	global $flogfull;
	global $flogerr;
	$fulllog = $logbase . "." . $index . ".log";
	$errlog = $logbase . "." . $index . ".err";
	$flogfull = fopen($fulllog, "a");
	$flogerr = fopen($errlog, "a");
}

function CloseLogs()
{
	global $flogfull;
	global $flogerr;
	fclose($flogfull);
	fclose($flogerr);
	$flogfull = null;
	$flogerr = null;
}

function OpenPreviousEventFile()
{
	global $eventbase;
	global $eventindex;
	$log = $eventbase . "." . ($eventindex-1) . ".event";
	return fopen($log, "r");
}

function OpenEventFile()
{
	global $eventbase;
	global $eventindex;
	$log = $eventbase . "." . $eventindex . ".event";
	return fopen($log, "a");
}

function OpenMarkovFile()
{
	global $logbase;
	global $eventindex;
	$log = $logbase . "." . $eventindex . ".markov";
	return fopen($log, "a");
}

function OpenWikiDataFile()
{
	global $logbase;
	global $eventindex;
	$log = $logbase . "." . $eventindex . ".lastwikidata";
	return fopen($log, "a");
}

function OpenStatsFile()
{
	global $logbase;
	global $eventindex;
	$log = $logbase . "." . $eventindex . ".stats";
	return fopen($log, "a");
}

function OpenHtmlStatsFile()
{
	global $htmlbase;
	global $eventindex;
	$log = $htmlbase . "." . $eventindex . ".stats.html";
	return fopen($log, "a");
}


// Figure out event index to use for this run, and start loggers.

$events = db_QueryFetch(
		"SELECT
			n.id, n.name, n.slug, 
			".DB_FIELD_DATE('n.modified', 'modified')."
		FROM
			".SH_TABLE_PREFIX.SH_TABLE_NODE." AS n
		WHERE n.type = 'event'
		ORDER BY n.id
		LIMIT 500
		;"
	);

$eventindex = count($events) + 1;

if($enable_file_logs)
{
	OpenLogs($eventindex);
}

stats_init();

if($usewikitext)
{
	SetupTextGeneration();
}

/*
	Stages definition:
Each stage is a hashtable with a number of properties that are used to determine the behavior in that stage.
Properties:
	Name => Name to display for the stage
	Phases => if present, number indicating how many phases there are to the stage (otherwise just one)
	MaxMinutes => if present, override the time for each phase in this stage to avoid spending a lot of time on it.
	MaxEventsPerUser => if present, impose a hard limit on events per user for each phase in this stage to avoid spending a lot of time on this section.
	StageStart => Function that is called when the stage starts
	StageEnd => Function that is called when the stage ends
	PhaseStart => Function to be called when a phase starts
	PhaseEnd => Function to be called when a phase ends
	
	Always => List of functions (actions) to be called by all simulated users in this phase
	LowChance => List of functions (actions) to be called by a few (at least one, but less than half) of the simulated users in this phase. Each function gets its own list of users
	HighChance => list of functions (actions) to be called by most (not all, but at least half) of the simulated users in this phase. Each function gets its own list of users
	
	UserVerify => Function that is called arbitrarily to ask the system to verify that the data it receives from the website for a specific user is consistent with what it expects.
	
About start/end functions:
	Stage start and end have no argument
	Phase start and end are passed the current phase index as an argument.
	
About actions:
	The action function is always called to ask a specific user to take action.
	The action function is passed a user array, and the phase index.
	if the action function returns false, it will not be called again for that user in that phase. Otherwise it may be called multiple times.
	
About reporting errors:
	TBD
	
*/
$stages = array(
	// First stage, create users and generate the event
	array(
		"Name" => "Setup",
		"StageStart" => 'SetupEvent',
		"MaxMinutes" => 1,
		"MaxEventsPerUser" => 3,
		"LowChance" => array('PostImIn', 'CommentOnPost') // Early "I'm In" posts
	),
	// Second stage, Theme voting
	array(
		"Name" => "Theme Voting",
		"Phases" => 7, // Theme suggestion + theme slaughter + 4 rounds of voting + theme selection
		"MaxMinutes" => 1, // This is per phase
		"MaxEventsPerUser" => 5,
		"PhaseStart" => 'SetupThemePhase',
		"HighChance" => ['UserVoteOnTheme'],
		"LowChance" => array('PostImIn', 'CommentOnPost', 'LikePosts', 'CommentUnlike')  // More various "I'm In" posts will trickle in
	),
	// Third stage, LD Starts!
	array(
		"Name" => "Compo Running",
		"StageStart" => 'StartCompo',
		"HighChance" => array('CompoPostUpdate', 'CompoEditGame', 'CommentOnPost', 'LikePosts'),
		"LowChance" => array('CommentOnGame', 'CompoPublishGame', 'CommentUnlike')
	),
	// Fourth stage, Submission deadline
	array(
		"Name" => "Compo Submission Period",
		"StageStart" => 'SetupSubmission',
		"MaxMinutes" => 2,
		"MaxEventsPerUser" => 10,
		"HighChance" => array('CommentOnGame', 'CompoPublishGame', 'LikePosts'),
		"LowChance" => array('CompoPostUpdate', 'CompoEditGame', 'CommentOnPost', 'CommentUnlike'),
	),
	// Fifth stage, Voting
	array(
		"Name" => "Compo Voting",
		"StageStart" => 'SetupVoting',
		"MaxEventsPerUser" => 80,
		"HighChance" => array('CommentOnGame', 'VoteOnGame', 'LikePosts', 'LikeGames'),
		"LowChance" => array('CommentOnPost', 'CompoEditGame', 'CompoPostUpdate', 'CommentUnlike')
	),
	// Sixth stage - Closed / resuts
	array(
		"Name" => "Compo Results",
		"StageStart" => 'EndCompo',
		"LowChance" => array('CommentOnGame', 'CommentOnPost', 'CompoEditGame', 'CompoPostUpdate', 'CommentUnlike', 'CompoPostResults', 'LikePosts', 'LikeGames')
	)
);


$event_admin_user = null;
$event_users = array(); // Only use for reference (e.g. getting usernames)
$event_user_lookup = array(); // Only use this as a source for user objects, and get them by reference.

$event_nodeid = null;
$event_name = null;


function LoadPreviousUsers()
{
	global $event_admin_user, $event_users;
	$f = OpenPreviousEventFile();
	$users=[];
	if($f === false) { return false; }
	
	while(!feof($f))
	{
		$line = fgets($f);
		$start = substr(trim($line),0,1);
		if($start === false || $start == "#") { continue; }
		$parts = explode(":",$line,2);
		if(count($parts) != 2) { continue; }
		$u = trim($parts[0]);
		$p = trim($parts[1]);
		$users[] = User_Load($u,$p);
	}
	
	global $usercount;
	if(count($users) != ($usercount+1)) { return false; } // Future: be smarter. Could maybe just generate / discard some users to fix this mismatch.
	
	$event_admin_user = array_shift($users);
	$event_users = $users;
	return true;
}

function GenerateNewUsers()
{
	global $event_admin_user, $event_users;
	
	$event_admin_user = User_Create();
	
	// Now create the normal users
	global $usercount;
	for($i=0;$i < $usercount; $i++)
	{
		$event_users[] = User_Create();
	}
}



// Prepare the event. Create an admin superuser. Create all the compo users. Create the new LudumDare event. Publish the event node.
// Some of this has to be done through the database directly (finding the email verification links, and creating the ludumdare event and setting it up)
// We'll also use some data from the database to make the naming a bit more friendly.
function SetupEvent()
{
	global $event_admin_user, $event_users, $event_user_lookup, $event_name;
	global $useprevioususers;
	
	$usersloaded = false;
	if($useprevioususers)
	{
		$usersloaded = LoadPreviousUsers();
	}
	if($usersloaded)
	{
		Verbose("Loaded users from previous event.");
		
		// Todo: User shift (replace a few users with new users)
		
	}
	else
	{
		Verbose("Generating new users for this event.");
		GenerateNewUsers();
	}

	foreach($event_users as $user)
	{
		$event_user_lookup[$user["username"]] = $user;
	}
	
	// Now generate an event
	global $event_nodeid;
	global $eventindex;
	$parentnode = 1; // Future: build out a more complex structure for this test.
	$author = $event_admin_user["id"];
	$eventname = "Testumdare " . ($eventindex);  
	$event_name = $eventname;
	$eventbody = GenerateRandomPostText();
	
	$starttime = time();
	$endtime = $starttime + 48*60*60;
	$formatStart = gmdate("Y-m-d\TH:i:s\Z", $starttime);
	$formatEnd = gmdate("Y-m-d\TH:i:s\Z", $endtime);


	// Promote our admin user to administrator
	nodeMeta_AddByNode($author, SH_NODE_META_PUBLIC, 'can-create', 'event');
	// Set a meta through the API to cause cache invalidation
	if(!ApiNodeMetaAdd($event_admin_user, $author, 'real-name', "Super Admin User")) ReportError("Failed to add user meta through API");


	// Create event
	$event_nodeid = node_Add( $parentnode, $author, "event", "", "", null, $eventname, $eventbody);

	// Add metadata
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'event-start', $formatStart);
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'event-end', $formatEnd);

	// Create metadata for grading
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-01', 'Overall');
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-02', 'Silliness');
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-03', 'Hexadecimal');
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-04', '100101101001');
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-05', 'Logicality');
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-06', 'Complexity');
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-07', 'Infinitude');
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-08', 'Waterproofness');

	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-05-optional', 1);
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-06-optional', 1);
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-07-optional', 1);
	nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'grade-08-optional', 1);

	// Add last meta through API, to invalidate cache.
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'can-create', 'item/game')) ReportError("Failed to add event meta through API");
	
	// Also publish the event
	if(!ApiNodePublish($event_admin_user, $event_nodeid))
	{
		ReportError("Failed to publish the event node.");
	}

	// Make featured
	nodeMeta_AddByNode(1, SH_NODE_META_PUBLIC, 'featured', "$event_nodeid");
	
	
	// Save information about the users into a file
	$f = OpenEventFile();
	fwrite($f, "# For now, just spitting out event data in a semi human readable form.\n");
	fwrite($f, "# First line is Admin, rest of the lines are normal users.\n");
	fwrite($f, "# Each line is Username:Password\n");
	
	fwrite($f, $event_admin_user["username"] . ":" . $event_admin_user["password"] . "\n");

	foreach($event_users as $u)
	{
		fwrite($f, $u["username"] . ":" . $u["password"] . "\n");	
	}

	fclose($f);
}

// Set up for each of the phases of the theme selection, in sequence.
function SetupThemePhase($phase)
{
	global $event_nodeid, $event_admin_user;
	
	switch($phase)
	{
	case 0: // Theme Suggestion
		Message("Starting Theme Suggestion");
		if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'can-theme', '1')) ReportError("Failed to add event meta through API");
		if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '1')) ReportError("Failed to add event meta through API");
		break;
		
	case 1: // Theme Slaughter
		Message("Starting Theme Slaughter");
		Verbose("Run external tool to perform suggestion deduplication");
		LogExec("sudo php ~/www/src/shrub/tools/theme/theme itsautomatic dupes");
	
		if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '2')) ReportError("Failed to add event meta through API");
		break;
	
	case 2: // Theme voting
		Message("Starting Theme Voting Round 1");	
		Verbose("Run external tool to score theme slaughter");
		LogExec("sudo php ../src/shrub/tools/theme/theme itsautomatic score");
		
		Verbose("Run external tool to populate theme voting pages");
		LogExec("sudo php ../src/shrub/tools/theme/theme itsautomatic simple-vote 3");
	
		nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'theme-page-mode-1', 1); // This meta isn't yet supported to be added by admin.
		if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '4')) ReportError("Failed to add event meta through API");
		break;
		
	case 3:
		Message("Starting Theme Voting Round 2");	
		nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'theme-page-mode-2', 1);
		if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '4')) ReportError("Failed to add event meta through API");
		break;
		
	case 4:
		Message("Starting Theme Voting Round 3");	
		nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'theme-page-mode-3', 1);
		if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '4')) ReportError("Failed to add event meta through API");
		break;

	case 5:
		Message("Starting Final Theme Voting Round");	
		Verbose("Running external tool to sum votes and populate final round");
		LogExec("sudo php ../src/shrub/tools/theme/theme itsautomatic calc 1");
		LogExec("sudo php ../src/shrub/tools/theme/theme itsautomatic calc 2");
		LogExec("sudo php ../src/shrub/tools/theme/theme itsautomatic calc 3");
		LogExec("sudo php ../src/shrub/tools/theme/theme itsautomatic finalize 10"); // Compute top 10 scoring themes into final round.
		
		nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'theme-page-mode-4', 1);
		nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'theme-page-name-4', "Final Round");
		if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '4')) ReportError("Failed to add event meta through API");
		break;

	case 6: // Final theme selection
		nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'theme-page-mode-1', 2);
		nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'theme-page-mode-2', 2);
		nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'theme-page-mode-3', 2);
		nodeMeta_AddByNode($event_nodeid, SH_NODE_META_PUBLIC, 'theme-page-mode-4', 2);
		if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '5')) ReportError("Failed to add event meta through API");
		
		
		Verbose("Run external tool to compute stats for final round");
		LogExec("sudo php ../src/shrub/tools/theme/theme itsautomatic calc 4");
		
		// Determine theme from the data
		$themes = themeList_GetByNode($event_nodeid, 4);
		
		$cmp = function($a, $b) {
			if ($a['score'] == $b['score']) {
				return 0;
			}
			return ($a['score'] > $b['score']) ? -1 : 1;
		};
		usort($themes, $cmp);		

		$theme = "Fluffy Bunnies";
		if(count($themes) > 0)
		{
			$theme = $themes[0]["theme"];
		}
		Message("Setting Event theme to $theme");
		if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'event-theme', $theme)) ReportError("Failed to add event meta through API");

		nodeCache_InvalidateById($event_nodeid);
		break;
	}
}

// The compo has now started, the theme voting is now locked and a theme is selected. The users will be sure to mention the theme in some of their posts.
function StartCompo()
{
	global $event_nodeid, $event_admin_user;
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '5')) ReportError("Failed to add event meta through API");
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'can-publish', '1')) ReportError("Failed to add event meta through API");
}

// The compo has now stopped and will only accept submissions for a limited amount of time. Configure the event to this mode.
function SetupSubmission()
{
	global $event_nodeid, $event_admin_user;
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '6')) ReportError("Failed to add event meta through API");
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'can-publish', '1')) ReportError("Failed to add event meta through API");
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'can-grade', '1')) ReportError("Failed to add event meta through API");
}

// Submission is over, and now the voting period begins
function SetupVoting()
{
	global $event_nodeid, $event_admin_user;
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '6')) ReportError("Failed to add event meta through API");
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'can-publish', '0')) ReportError("Failed to add event meta through API");
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'can-grade', '1')) ReportError("Failed to add event meta through API");
}

// Voting is over, close out the compo.
function EndCompo()
{
	global $event_nodeid, $event_admin_user;
	
	Verbose("Computing results...");
	LogExec("sudo php ../src/shrub/tools/grade/grade itsautomatic score compo 7"); # Require 7 ratings to be placed.
	LogExec("sudo php ../src/shrub/tools/grade/grade itsautomatic score jam 7"); # Require 7 ratings to be placed.
	
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'theme-mode', '8')) ReportError("Failed to add event meta through API");
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'can-grade', '0')) ReportError("Failed to add event meta through API");
	if(!ApiNodeMetaAdd($event_admin_user, $event_nodeid, 'event-finished', '1')) ReportError("Failed to add event meta through API");
}

// User should discover and interact with the available options in the current theme voting phase.
function UserVoteOnTheme(&$user, $phase)
{
	global $event_nodeid;
	
	switch($phase)
	{
	case 0: // Theme Suggestion
		$suggest_count = random_int(1,3);
		$existing_themes = ApiThemeIdeaGetmy($user, $event_nodeid);
		$theme_keys = array_keys($existing_themes);
		if($existing_themes === null)
		{
			ReportError("Failed to GetMy Theme Ideas");
			return false;
		}
		$total = $suggest_count + count($existing_themes);
		while($total > 3)
		{
			$removeid = array_shift($theme_keys);
			Verbose("Removing theme ".$existing_themes[$removeid]);
			// Remove themes!
			if(null === ApiThemeIdeaRemove($user, $event_nodeid, $removeid))
			{
				ReportError("Failed to remove theme!");
			}
			$total--;
		}
		
		for($i=0;$i<$suggest_count;$i++)
		{
			$suggestion = GenerateRandomPhrase(1,4);
			Verbose("Suggesting theme $suggestion");
			if(null === ApiThemeIdeaAdd($user, $event_nodeid, $suggestion))
			{
				ReportError("Failed to suggest theme!");
			}
		}
		
		$existing_themes = ApiThemeIdeaGetmy($user, $event_nodeid);
		if($existing_themes === null)
		{
			ReportError("Failed to GetMy Theme Ideas again");
			return false;
		}
		
		if(count($existing_themes) < 1)
		{
			ReportError("Suggested themes were not returned in theme/idea/getmy");
		}
		break;
		
	case 1: // Theme Slaughter
		$slaughter_count = random_int(5,20);
		
		$allslaughter = ApiThemeIdeaVoteGet($user, $event_nodeid);
		if(null === $allslaughter)
		{
			ReportError("Failed to get theme suggestions for slaughter");
			return false;
		}
		
		Verbose("Got ".count($allslaughter)." slaughter items - Going to vote on $slaughter_count");
		$keys = array_keys($allslaughter);
		for($i=0;$i<$slaughter_count;$i++)
		{
			$index = random_int(1,count($keys))-1;
			$id = $keys[$index];
			
			$value = random_int(0,1); // vote yes/no.
			if(random_int(1,100) == 1) 
			{
				$value = -1; // Occasionally, flag.
			}
			
			if(null === ApiThemeIdeaVoteSet($user, $id, $value))
			{
				ReportError("Failed to theme/idea/vote");
			}
		}
	
		$myslaughter = ApiThemeIdeaVoteGet($user, $event_nodeid);
		if(count($myslaughter) < 1)
		{
			ReportError("Expected to see slaughter votes, but did not find any");
		}
		
		break;
		
	case 2: // Theme voting
	case 3:
	case 4:
	case 5:
		$page = $phase-1;
		
		$votecount = random_int(2,10);
	
		$voteable = ApiThemeListGet($user, $event_nodeid, $page);
		if($voteable === null) 
		{
			ReportError("Unable to get theme voting list");
			return false;
		}
		if(count($voteable) == 0)
		{
			Verbose("Warning: Voting page $page does not have any entries to vote on!");
			return false;
		}
	
		Verbose("Got ".count($voteable)." theme voting items - Going to vote on $votecount");
		for($i=0;$i<$votecount;$i++)
		{
			$index = random_int(1,count($voteable))-1;
			$vote = random_int(0,2)-1;
			
			$result = ApiThemeListVoteSet($user, $voteable[$index]["id"], $vote);
			if($result === null)
			{
				ReportError("Api rejected theme list vote");
			}
		}

		$myvotes = ApiThemeListVoteGetmy($user, $event_nodeid);
		if(count($myvotes) < 1)
		{
			ReportError("Expected to see theme votes, but did not find any");
		}
	
		break;
	case 6: // Final theme selection	
		return false; // Nothing to do in this case.
	}
	
	return true;
}


// Post a very simple "I'm In" post. Only do this once per event.
function PostImIn(&$user, $phase)
{
	if($user["postedimin"]) return false;
	
	$title = "I'm In";
	$body = "I'm In " . GenerateRandomPostText();
	CreatePost($user, $title, $body);
	
	$user["postedimin"] = true;
	return false;
}


// Read through recent posts and comments on them, and randomly like comments
function LikePosts(&$user, $phase)
{
	$posts = GetRecentEventPosts($user);
	if($posts != null)
	{
		LikeFeed($user, $posts);
	}
	return true;
}

// Read through highly sorted games and comments on them, and randomly like comments
function LikeGames(&$user, $phase)
{
	$posts = GetTopGames($user);
	if($posts != null)
	{
		LikeFeed($user, $posts);
	}
	return false;
}

// Helper: given a list of nodes, like at least one of them, and examine comments.
function LikeFeed(&$user, $nodes)
{
	if($nodes == null || count($nodes) == 0) return;
	
	$likecount = 0;
	foreach($nodes as $n)
	{
		if(random_int(1,10) == 1) LikeCommentsNode($user, $n);
		if(random_int(1,40) == 1)
		{
			$likecount++;
			LikeNode($user, $n["id"]);
		}
	}
	if($likecount == 0)
	{
		$n = $nodes[random_int(1,count($nodes))-1];
		LikeNode($user, $n["id"]);		
	}	
}

// Helper: fetch a node's comments, and maybe like some of them.
function LikeCommentsNode(&$user, $node)
{
	$comments = GetNodeComments($user, $node["id"]);
	if($comments != null)
	{
		foreach($comments as $c)
		{
			if(random_int(1,20) == 1) LikeComment($user, $c["id"]);
		}
	}
}

// Find a recent post in the feed, and post a comment - and optionally give it or one of its comments a like.
function CommentOnPost(&$user, $phase)
{
	$commentcount = random_int(1,5);
	for($i=0;$i<$commentcount;$i++)
	{
		$post = GetRandomRecentPost($user);
		if($post != null)
		{
			$body = GenerateRandomPostText();
			CreateComment($user, $post["id"], $body);
		}
	}
	return true;
}

// Find a game through one of the game lists, and give it a comment, and optionally give it or one of its comments a like.
function CommentOnGame(&$user, $phase)
{
	$commentcount = random_int(1,3);
	for($i=0;$i<$commentcount;$i++)
	{
		$post = GetRandomTopGame($user);
		if($post != null)
		{
			$body = GenerateRandomPostText();
			CreateComment($user, $post["id"], $body);
		}
	}
	return true;
}
// Find a game through one of the game lists, and vote on it. Or change the votes to something else.
function VoteOnGame(&$user, $phase)
{
	$games = GetTopGames($user);
	
	$rate_count = random_int(5,10);
	// Walk through games in order until we find a number of games we haven't ranked.
	// For games we havne't ranked, vote on them and add to the ranked list.
	
	foreach($games as $game)
	{
		$id = $game["id"];
		if(key_exists($id, $user["rated_games"])) 
		{ 
			// Chance to re-rate a rated game, but usually we'll rate new games.
			if(random_int(1,20) != 1) { continue; } 
		}
		
		Verbose("Voting on game ID $id");
		
		// Future, consider opt-outs on this game. For now just vote all categories.
		// We know there are 8 categories, so hardcoding for now
		
		for($i=1;$i<=8;$i++)
		{
			$value = random_int(1,10) / 2.0;
			$result = ApiGradeAdd($user,$id,"grade-0".$i,$value);
			if($result === null)
			{
				ReportError("Failed to add vote");
			}
		}
	
		// Sometimes randomly remove one of the votes, to test that path
		if(random_int(1,10) == 1)
		{
			$remove = random_int(1,8);
			$result = ApiGradeRemove($user,$id,"grade-0".$remove);
			if($result === null)
			{
				ReportError("Failed to remove vote");
			}
		}
		
		$grades = ApiGradeGetmy($user,$id);
		if(count($grades) < 1)
		{
			ReportError("My grades don't appear for this node.");
		}

		$user["rated_games"][$id] = true;
		$rate_count--;
		if($rate_count < 1) { break; }
	}
	RunMagic();
	return true;
}

// Remove a like from some post/comment/game that was liked previously. The simulated user revisits the node and comments, and removes the like.
function CommentUnlike(&$user, $phase)
{
	UnlikeRandom($user);
	return false;
}

// Generate and post a new item to the compo feed
function CompoPostUpdate(&$user, $phase)
{
	$title = GenerateRandomPostTitle();
	$body = GenerateRandomPostText(5);
	CreatePost($user, $title, $body);
	
	// There's a limit to how many posts a user should make. Try not to make too many more.
	return count($user["posts"]) < 3;
}

// And this is the part of the game where some users wish to parade their stats into the news feed, or complain about PoV :)
function CompoPostResults(&$user, $phase)
{
	return false;
}

// Modify the record for the current user's game and submit an update.
function CompoEditGame(&$user, $phase)
{
	// For now, just carelessly replace everything. Future: do something smarter.
	$title = GenerateRandomPostTitle();
	$body = GenerateRandomPostText(6);
	ModifyGame($user, $title, $body);
	return true;
}
// Can only be called once. If the game is not published, publish it.
function CompoPublishGame(&$user, $phase)
{
	// Need to ensure there is something good before publish.
	$title = GenerateRandomPostTitle();
	$body = GenerateRandomPostText(6);
	ModifyGame($user, $title, $body);

	PublishGame($user);
	return false;
}


////
//// Quickly sanity check that all functions referenced in the above state system actually exist.
//// 
function EnsureFunction($funcname)
{
	if(!function_exists($funcname))
	{
		ReportError("Fatal error - Function ".$funcname.' referenced in the $stages array does not exist.');
		exit(1);
	}
}
function EnsureFunctionKey(&$stage, $keyname)
{
	if(key_exists($keyname, $stage)) { EnsureFunction($stage[$keyname]); }
}
function EnsureFunctionArray(&$stage, $keyname)
{
	if(key_exists($keyname, $stage)) 
	{
		foreach($stage[$keyname] as $f) EnsureFunction($f);
	}
}

foreach($stages as $stage)
{
	EnsureFunctionKey($stage, "StageStart");
	EnsureFunctionKey($stage, "StageEnd");
	EnsureFunctionKey($stage, "PhaseStart");
	EnsureFunctionKey($stage, "PhaseEnd");
	EnsureFunctionKey($stage, "UserVerify");
	EnsureFunctionArray($stage, "Always");
	EnsureFunctionArray($stage, "LowChance");
	EnsureFunctionArray($stage, "HighChance");
}


////
//// Code to drive the stage progression based on the $stages variable defined above.
////
$stagecount = count($stages);


for($curStage = 0; $curStage < $stagecount; $curStage++)
{
	$stage = $stages[$curStage];
	Message("Starting stage " . $curStage . " - " . $stage["Name"]);

	// Start stage function
	if(key_exists("StageStart",$stage)) { $stage["StageStart"](); }

	$phasecount = 1;
	$hasPhases = false;
	if(key_exists("Phases", $stage)) { 
		$hasPhases = true;
		$phasecount = $stage["Phases"];
	}

	for($phase = 0; $phase < $phasecount; $phase++)
	{
		if($hasPhases)
		{
			Message("Beginning Phase ".$phase);
		}
		if($hasPhases && key_exists("PhaseStart",$stage)) { $stage["PhaseStart"]($phase); }

		PrepareStageActions($stage, $phase);

		// Determine proper action limiting mechanism
		if($runminutes)
		{
			// Use temporal limiting
			$minutes = $runminutes;
			if($stage["MaxMinutes"])
			{
				$minutes = Math.min($minutes, $stage["MaxMinutes"]);
			}
			$end = (new DateTime()).Add(new DateInterval("PT".$minutes."M"));
			Message("Running for ".$minutes." minute".($minutes == 1?"":"s"));
			
			while($end > new DateTime())
			{
				if(!ExecuteStageAction($stage, $phase))
				{
					// Still wait for the period to complete before continuing
					usleep(10000); // Delay 10ms
				}
			}
		}
		else
		{
			// Use event count limiting
			for($action = 0; $action < $runactions; $action++)
			{
				if(!ExecuteStageAction($stage, $phase))
				{
					break;
				}
			}
		}
		
		// Ensure promised conditions about mandatory actions hold
		CompleteMandatoryStageActions($stage, $phase);

		if($hasPhases && key_exists("PhaseEnd",$stage)) { $stage["PhaseEnd"]($phase); }

	}

	// End stage function
	if(key_exists("StageEnd",$stage)) { $stage["StageEnd"](); }
  
}
Message("All Stages Complete!");

	RunMagic();


$currentstageactions = null;

function PrepareStageActions($stage, $phase)
{
	global $event_users;
	global $event_user_lookup;
	global $currentstageactions;
	$currentstageactions = [ "Allowed" => [], "Required" => [], "Users" => [], "ActiveUsernames" => [], "ActionCount" => [] ];
	
	// Extract actions out from stage	
	// Always => List of functions (actions) to be called by all simulated users in this phase
	// LowChance => List of functions (actions) to be called by a few (at least one, but less than half) of the simulated users in this phase. Each function gets its own list of users
	// HighChance => list of functions (actions) to be called by most (not all, but at least half) of the simulated users in this phase. Each function gets its own list of users
	
	if(key_exists("Always",$stage))
	{
		foreach($stage["Always"] as $action)
		{
			foreach($event_users as $u)
			{	
				$currentstageactions["Allowed"][$u["username"]][] = $action;
				$currentstageactions["Required"][$u["username"]][] = $action;
			}
		}
	}
	$usercount = count($event_users);
	$halflow = floor($usercount/2);
	$halfhigh = ceil($usercount/2);
	
	if(key_exists("LowChance",$stage))
	{
		foreach($stage["LowChance"] as $action)
		{
			$users = random_int(1, $halfhigh);
			$randomusers = PickRandomSubset($event_users, $users);
			
			foreach($randomusers as $u)
			{	
				$currentstageactions["Allowed"][$u["username"]][] = $action;
				$currentstageactions["Required"][$u["username"]][] = $action;
			}
		}	
	}
	if(key_exists("HighChance",$stage))
	{
		foreach($stage["HighChance"] as $action)
		{
			$users = random_int($halflow, $usercount);
			$randomusers = PickRandomSubset($event_users, $users);
			
			foreach($randomusers as $u)
			{	
				$currentstageactions["Allowed"][$u["username"]][] = $action;
				$currentstageactions["Required"][$u["username"]][] = $action;
			}
		}	
	}	

	$eventsperuser = -1;
	if(key_exists("MaxEventsPerUser",$stage)) { $eventsperuser = $stage["MaxEventsPerUser"]; } 
	
	// Compute ActiveUsernames from users that have actions still.
	foreach($event_users as $u)
	{
		$n = $u["username"];
		if(key_exists($n,$currentstageactions["Allowed"]) && count($currentstageactions["Allowed"][$n]) > 0)
		{
			$currentstageactions["ActiveUsernames"][] = $n;
		}
		$currentstageactions["ActionCount"][$n] = $eventsperuser;
	}
	
}

function PickRandomSubset($objects, $count)
{
	$subset = [];
	for($i = 0;$i < $count && count($objects) > 0; $i++)
	{
		$pick = random_int(1,count($objects))-1;
		$subset[] = $objects[$pick];
		if($pick < (count($objects)-1)) { $objects[$pick] = $objects[count($objects)-1]; }
		unset($objects[count($objects)-1]);
	}
	return $subset;
}

function RemoveElement(&$location, $action)
{
	$index = array_search($action, $location);
	if($index === false) return;
	
	$last = count($location)-1;
	if($index != $last)
	{
		$location[$index] = $location[$last];
	}
	unset($location[$last]);
}

$ActionContext = [];

function ExecuteAction(&$user, $action, $phase)
{
	$username = $user["username"];
	
	VerboseAction("Running action ".$action." with user ".$username);
	$GLOBALS["ActionContext"] = ["action" => $action];

	return $action($user,$phase);
}

function ExecuteStageAction($stage, $phase)
{
	global $currentstageactions;	
	global $event_user_lookup;	
	if(count($currentstageactions["ActiveUsernames"]) == 0) return false; // Nothing to do!
	
	// Pick a random user from the active usernames
	$userindex = random_int(1,count($currentstageactions["ActiveUsernames"]))-1;
	$username = $currentstageactions["ActiveUsernames"][$userindex];
	$user = &$event_user_lookup[$username];
	
	// Pick a random action from the available actions
	$actions = $currentstageactions["Allowed"][$username];
	if(count($actions) < 1)
	{
		ReportError("Debug - something has gone wrong.");
		print_r($username);
		print_r($currentstageactions);
		return true;
	}
	$actionindex = random_int(1, count($actions)) - 1;
	$action = $actions[$actionindex];
	
	// Execute the action
	$result = ExecuteAction($user, $action, $phase);
	
	// Unmark the action from the Required list if present
	RemoveElement($currentstageactions["Required"][$username], $action);
	
	// If the action has requested a stop, remove this action from the Allowed list, and possibly remove this username from the active usernames list.
	if($result === false)
	{
		RemoveElement($currentstageactions["Allowed"][$username], $action);
		if(count($currentstageactions["Allowed"][$username]) == 0)
		{
			RemoveElement($currentstageactions["ActiveUsernames"], $username);
		}
	}
	
	// Decrement action count & disable username if it hits zero.
	$currentstageactions["ActionCount"][$username]--;
	if($currentstageactions["ActionCount"][$username] == 0)
	{
		RemoveElement($currentstageactions["ActiveUsernames"], $username);
	}
	
	return true;
}

function CompleteMandatoryStageActions($stage, $phase)
{
	// Complete any remaining Required actions that we didn't get to already (and remove from the list).
	global $currentstageactions;	
	global $event_user_lookup;	
	foreach($currentstageactions["Required"] as $u => $actions)
	{
		$user = &$event_user_lookup[$u];
		
		foreach($actions as $action)
		{
			ExecuteAction($user, $action, $phase);
		}
	}
}


////
//// Common functions to assist in doing normal tasks in the site
////

function User_DataStructure($username, $password)
{
	$user = [
		"username" => $username,
		"password" => $password,
		"cookies" => array(),
		
		// Further info for tracking data this user has posted and interacted with.
		"joinedevent" => false,
		"game_node" => 0,
		"posts" => array(),
		"notes" => array(),
		"love" => array(),
		"rated_games" => array(),
		"postedimin" => false,
		"publishedgame" => false,
	];
	
	return $user;
}

function User_Load($username, $password)
{
	$user = User_DataStructure($username, $password);

	// Login the user
	$userid = ApiUserLogin($user);
	if(!$userid)
	{
		ReportError("Unable to login new user.");
		return null;	
	}
	
	$user["id"] = $userid;
	
	Verbose("Loaded user " . $username);
	
	return $user;
}

function User_Create()
{
	$username = GenerateRandomUsername();
	$password = GenerateRandomPassword();
	
	// Construct a user object
	$user = User_DataStructure($username, $password);
	
	// Determine if username is in use
	for($i = 0; $i < 20; $i++)
	{
		if(ApiUserHave($username))
		{
			// Username is in use, pick another
			$username = GenerateRandomUsername();
			$user["username"] = $username;
		}
		else
		{
			break;
		}
	}
	
	// API request to create user
	$email = $username . "@ludumdare.org";
	
	$mailsent = ApiUserCreate($email, $user);
	if(!$mailsent)
	{
		Verbose("Warning: User create didn't send mail. It's not strictly necessary to catch mail for this, but you probably don't have the mail catcher running.");
	}
	
	// Dig out the email auth token from the database and activate the user
	$userdata = user_GetByMail($email);
	$id = $userdata["id"];
	$key = $userdata["auth_key"];
	
	if(!ApiUserActivate($user, $id, $key))
	{
		ReportError("Error while creating user.");
		return null;
	}
	
		
	// Login the user
	$userid = ApiUserLogin($user);
	if(!$userid)
	{
		ReportError("Unable to login new user.");
		return null;	
	}
	
	$user["id"] = $userid;
	
	Verbose("Created user " . $username);
	
	return $user;
}

function User_EnsureJoined(&$user)
{
	global $event_nodeid;
	if(!$user["joinedevent"])
	{
		Verbose("Creating a game to join the event...");
		$user["game_node"] = ApiNodeAdd($user, $event_nodeid, "item/game");
		$user["joinedevent"] = true;
	}
}

function GetRandomRecentPost(&$user)
{
	Verbose("Fetching a random post...");
	$nodes = GetRecentEventPostNodes($user);
	if(count($nodes) == 0) return null;
	$i = random_int(1,count($nodes))-1;
	$data = ApiNodeGet($user, $nodes[$i]["id"]);
	if($data == null)
	{
		ReportError("Error fetching node " . $nodes[$i]);
		return null;
	}
	return $data[0];
}

function GetRandomTopGame(&$user)
{
	Verbose("Fetching a random game...");
	$nodes = GetTopEventGameNodes($user);
	if(count($nodes) == 0) return null;
	$i = random_int(1,count($nodes))-1;
	$data = ApiNodeGet($user, $nodes[$i]["id"]);
	if($data == null)
	{
		ReportError("Error fetching node " . $nodes[$i]);
		return null;
	}
	return $data[0];
}

function GetTopGames(&$user)
{
	Verbose("Reading over the top games...");
	$nodes = GetTopEventGameNodes($user);
	return GetNodesForFeed($user, $nodes);
}

function GetRecentEventPosts(&$user)
{
	Verbose("Reading over the recent posts...");
	$nodes = GetRecentEventPostNodes($user);
	return GetNodesForFeed($user, $nodes);
}

function WalkFeedId(&$feed, $key) { $feed = $feed["id"]; }

function GetNodesForFeed(&$user, $feed)
{
	if(count($feed) == 0) return [];
	$fullnodes = [];
	$chunks = array_chunk($feed, 30);
	foreach($chunks as $c)
	{
		array_walk($c, "WalkFeedId");
		$idjoin = implode("+",$c);
		$data = ApiNodeGet($user, $idjoin);
		if($data != null)
		{
			foreach($data as $n)
			{
				$fullnodes[$n["id"]] = $n;
			}
		}
	}
	$outdata = [];
	foreach($feed as $n)
	{
		$data = $fullnodes[$n["id"]];
		if($data != null) { $outdata[] = $data; }
	}
	if(count($outdata) == 0) return null;
	return $outdata;
}

function GetRecentEventPostNodes(&$user, $count = 60)
{
	global $event_nodeid;
	$maxpage = 30;
	$have = 0;
	$out = [];
	while($have < $count)
	{
		$fetch = $count - $have;
		if($fetch > $maxpage) $fetch = $maxpage;
		
		$newdata = ApiNodeFeed($user, $event_nodeid, "all", "post", $fetch, $have);
		if($newdata === null)
		{
			ReportError("Error getting feed.");
		}
		else
		{
			$out = array_merge($out, $newdata);
		}
		$have += $fetch;
	}
	
	if(count($out) == 0) return null;
	return $out;
}

function GetTopEventGameNodes(&$user, $count = 60)
{
	global $event_nodeid;
	$maxpage = 30;
	$have = 0;
	$out = [];
	while($have < $count)
	{
		$fetch = $count - $have;
		if($fetch > $maxpage) $fetch = $maxpage;
		
		$newdata = ApiNodeFeed($user, $event_nodeid, "smart+parent", "item/game/compo+jam", $fetch, $have);
		if($newdata === null)
		{
			ReportError("Error getting feed.");
		}
		else
		{
			$out = array_merge($out, $newdata);
		}
		$have += $fetch;
	}
	
	if(count($out) == 0) return null;
	return $out;
}

function GetNodeComments(&$user, $nodeid)
{
	Verbose("Reading Comments for node ".$nodeid."...");
	$notes = ApiNoteGet($user, $nodeid);
	if($notes === null)
	{
		ReportError("Failed to get notes for node ".$nodeid);
	}
	return $notes;
}

function CreatePost(&$user, $title, $body)
{
	User_EnsureJoined($user);
	
	Verbose("Creating a new post.");
	$nodeid = ApiNodeAdd($user, $user["game_node"], "post");
	if($nodeid == null)
	{
		ReportError("Failure to add new post!");
		return;
	}	
	if(!ApiNodeUpdate($user, $nodeid, $title, $body))
	{
		ReportError("Failure to update post being created.");
		return;
	}
	if(!ApiNodePublish($user, $nodeid))
	{
		ReportError("Failure to publish post being created.");
		return;
	}
	$user["posts"][] = $nodeid; // Track post for later use.
}

function CreateComment(&$user, $nodeid, $body)
{
	User_EnsureJoined($user);
	Verbose("Posting a comment to node " . $nodeid);
	$id = ApiNoteAdd($user, $nodeid, $body);
	if(!$id)
	{
		ReportError("Failed to add comment");
		return null;
	}
	$user["notes"][] = [ "Node" => $nodeid, "Note" => $id ];
}

function LikeNode(&$user, $nodeid)
{
	# If we haven't already, add a like to this node. 
	if(array_key_exists($nodeid, $user["love"])) return;

	Verbose("Add like for Node " . $nodeid);
	if(!ApiNodeLoveAdd($user, $nodeid))
	{
		ReportError("Error adding node love for ".$nodeid);
		return;
	}
	$user["love"][] = $nodeid;
}

function LikeComment(&$user, $commentid)
{
	# If we haven't already, add a like to this comment
	if(array_key_exists(-$commentid, $user["love"])) return;
	
	Verbose("Add like for Note " . $commentid);
	if(!ApiNoteLoveAdd($user, $commentid))
	{
		ReportError("Error adding note love for ".$commentid);
		return;
	}
	$user["love"][] = -$commentid;
}

function UnlikeRandom(&$user)
{
	$count = count($user["love"]);
	if($count < 1) return;
	
	$item = random_int(1,$count)-1;
	$remove = $user["love"][$item];
	if($remove == null) { print_r($user); }
	if($item != ($count-1)) $user["love"][$item] = $user["love"][$count-1];
	unset($user["love"][$count-1]);
	$user["love"] = array_values($user["love"]); // Reindex for good measure.
	
	RemoveLike($user, $remove);
}

function RemoveLike(&$user, $thing)
{
	// Positive numbers = node love, Negative numbers = note love
	if($thing < 0)
	{
		$thing = -$thing;
		Verbose("Remove note love ". $thing);
		if(!ApiNoteLoveRemove($user, $thing))
		{
			ReportError("Failed to remove note love for ". $thing);
		}
	}
	else
	{
		Verbose("Remove node love ". $thing);
		if(!ApiNodeLoveRemove($user, $thing))
		{
			ReportError("Failed to remove node love for ". $thing);
		}		
	}
}

function ModifyGame(&$user, $newTitle, $newBody)
{
	User_EnsureJoined($user);
	Verbose("Modifying game node information...");
	
	if(!ApiNodeUpdate($user, $user["game_node"], $newTitle, $newBody))
	{
		ReportError("Failure to update game.");
		return;
	}
}

function PublishGame(&$user)
{
	User_EnsureJoined($user);
	// Bail early if user already published game.
	if($user["publishedgame"]) return;
	
	Verbose("Publishing game node ".$user["game_node"]);
	
	// Transform game into compo or jam game
	$newtype = ["item/game/compo","item/game/jam"][random_int(0,1)];
	if(!ApiNodeTransform($user, $user["game_node"], $newtype))
	{
		ReportError("Failed to transform game node to " . $newtype);
	}
	
	// other stuff (future: enable opt-outs and stuff)
	
	
	// Publish!
	if(!ApiNodePublish($user, $user["game_node"]))
	{
		ReportError("Failed to publish game!");
	}
	
	$user["publishedgame"] = true;
	
	RunMagic();
}



////
//// API Interface wrapper functions
////

// Get one or more nodes
function ApiNodeGet(&$user, $nodeidlist)
{
	$value = LdApi::Get("vx/node/get/".$nodeidlist, $user);
	if($value != null)
	{
		return $value["node"];
	}
	return null; 
}

// Enumerate nodes related to an event
function ApiNodeFeed(&$user, $parentid, $methods, $type, $count, $offset = 0)
{ // GET node/feed/:node_id/:methods[]/:type/[:subtype]/[:subsubtype] ?offset= ?limit=

	$value = LdApi::Get("vx/node/feed/" . $parentid . "/" . $methods . "/" . $type . "?offset=" . $offset . "&limit=" . $count, $user);
	if($value != null)
	{
		return $value["feed"];
	}
	return null;
}

// Add item(/game[/compo, /jam]) or post (typically)
// Pass type,subtype,subsubtype together as $type.
function ApiNodeAdd(&$user, $parentid, $type)
{  // POST node/add/:parent/:type/:subtype/:subsubtype
	$value = LdApi::Post("vx/node/add/" . $parentid . "/" . $type , "", $user);
	if($value != null && key_exists("id",$value))
	{
		return $value["id"];
	}
	return null;
}

// Edit name and body of a node (either can be skipped with null) (tag is also an option, but overlooking that for now)
function ApiNodeUpdate(&$user, $nodeid, $newname = null, $newbody = null)
{ // POST node/update/:node_id
	$poststring = "";
	if($newname != null) { $poststring = "name=".urlencode($newname); }
	if($newbody != null)
	{
		if($poststring != "") { $poststring .= "&"; }
		$poststring .= "body=".urlencode($newbody);
	}

	$value = LdApi::Post("vx/node/update/" . $nodeid , $poststring, $user);
	return ResponseIs200($value);
}

// Change the type of a node (e.g. change item/game to item/game/compo, item/game/jam)
function ApiNodeTransform(&$user, $nodeid, $newtype)
{ // POST node/transform/:node_id/:type/[:subtype]/[:subsubtype]
	$value = LdApi::Post("vx/node/transform/" . $nodeid . "/" . $newtype, "", $user);
	return ResponseIs200($value);
}

// Just publish the node.
function ApiNodePublish(&$user, $nodeid)
{ // POST node/publish/:node_id
	$value = LdApi::Post("vx/node/publish/" . $nodeid, "", $user);
	return ResponseIs200($value);
}

function ApiNodeLoveAdd(&$user, $nodeid) //GET node/love/add/:node_id
{
	$value = LdApi::Get("vx/node/love/add/" . $nodeid, $user);
	return ResponseIs200($value);
}

function ApiNodeLoveRemove(&$user, $nodeid) //GET node/love/remove/:node_id
{
	$value = LdApi::Get("vx/node/love/remove/" . $nodeid, $user);
	return ResponseIs200($value);
}

function ApiNodeMetaAdd(&$user, $nodeid, $key, $value) // POST node/meta/add/:node_id
{
	$value = LdApi::Post("vx/node/meta/add/".$nodeid, urlencode($key)."=".urlencode($value), $user);
	return ResponseIs200($value);
}

function ApiNodeMetaRemove(&$user, $nodeid, $key) // POST node/meta/remove/:node_id
{
	$value = LdApi::Post("vx/node/meta/remove/".$nodeid, urlencode($key)."=", $user);
	return ResponseIs200($value);
}


function ApiNoteAdd(&$user, $nodeid, $body) // POST note/add
{
	$value = LdApi::Post("vx/note/add/".$nodeid,"parent=0&body=".urlencode($body), $user);
	if($value) { return $value["note"]; }
	return null;
}

function ApiNoteUpdate(&$user, $parentid, $noteid, $newbody)
{
	$value = LdApi::Post("vx/note/update/".$noteid,"node=".$parentid."&body=".urlencode($body), $user);
	return ResponseIs200($value);
}

// Get all notes for a node
function ApiNoteGet(&$user, $nodeid)
{
	$value = LdApi::Get("vx/note/get/" . $nodeid, $user);
	if($value)
	{
		return $value["note"];
	}
	return null;
}

function ApiNoteLoveAdd(&$user, $noteid)
{
	$value = LdApi::Get("vx/note/love/add/" . $noteid, $user);
	return ResponseIs200($value);
}

function ApiNoteLoveRemove(&$user, $noteid)
{
	$value = LdApi::Get("vx/note/love/remove/" . $noteid, $user);
	return ResponseIs200($value);
}


// Does the site have this username already?
function ApiUserHave($username)
{
	$value = LdApi::Post("vx/user/have","name=".urlencode($username));
	if($value != null)
	{
		return !($value["available"]);
	}
	return false;
}

// Create a new user (by email address)
function ApiUserCreate($email, &$user)
{
	$value = LdApi::Post("vx/user/create","mail=".urlencode($email), $user);
	if($value != null)
	{
		return $value["sent"];
	}
	return false;
}

function ApiUserActivate(&$user, $id, $auth_key)
{
	$name = $user["username"];
	$pw = $user["password"];
	
	$postString = "id=".$id."&key=".$auth_key."&name=".urlencode($name)."&pw=".urlencode($pw);
	$value = LdApi::Post("vx/user/activate",$postString,$user);
	
	if($value != null)
	{
		return $value["response_httpcode"] == "201";
	}
	return false;
}

function ApiUserLogin(&$user)
{
	$login = $user["username"];
	$pw = $user["password"];
	
	$value = LdApi::Post("vx/user/login", "login=".urlencode($login)."&pw=".urlencode($pw), $user);
	
	if($value != null)
	{
		if($value["response_httpcode"] == "200")
		{
			return $value["id"];
		} 
	}
	return 0;
}


function ApiThemeIdeaGetmy(&$user, $event_id)
{
	$value = LdApi::Get("vx/theme/idea/getmy/".$event_id, $user);
	if(!ResponseIs200($value)) { return null; }
	return $value["ideas"];
}

function ApiThemeIdeaAdd(&$user, $event_id, $themeidea)
{
	$value = LdApi::Post("vx/theme/idea/add/".$event_id, "idea=".urlencode($themeidea), $user);
	if(!ResponseIs201($value)) { return null; }
	return $value["response"];
}

function ApiThemeIdeaRemove(&$user, $event_id, $themeid)
{
	$value = LdApi::Post("vx/theme/idea/remove/".$event_id, "id=$themeid", $user);
	if(!ResponseIs201($value)) { return null; }
	return $value["response"];
}

// Returns all theme ideas
function ApiThemeIdeaVoteGet(&$user, $event_id)
{
	$value = LdApi::Get("vx/theme/idea/vote/get/".$event_id, $user);
	if(!ResponseIs200($value)) { return null; }
	return $value["ideas"];
}

// Return your theme slaughter votes
function ApiThemeIdeaVoteGetmy(&$user, $event_id)
{
	$value = LdApi::Get("vx/theme/idea/vote/getmy/".$event_id, $user);
	if(!ResponseIs200($value)) { return null; }
	return $value["votes"];
}

// Vote (either +1, -1, or 0)
function ApiThemeIdeaVoteSet(&$user, $idea_id, $vote)
{
	$votetype = [ -1 => "flag", 0 => "no", 1 => "yes" ];
	$type = $votetype[$vote];
	$value = LdApi::Get("vx/theme/idea/vote/$type/$idea_id", $user);
	if(!ResponseIs200($value)) { return null; }
	return $value["id"]; // Vote ID. Not that it matters.
}

// Get a single page (The API can also return all pages, but don't care at the moment)
function ApiThemeListGet(&$user, $event_id, $page)
{
	$value = LdApi::Get("vx/theme/list/get/$event_id/$page", $user);
	if(!ResponseIs200($value)) { return null; }
	return $value["lists"][$page];
}

function ApiThemeListVoteGetmy($user, $event_id)
{
	$value = LdApi::Get("vx/theme/list/vote/getmy/$event_id", $user);
	if(!ResponseIs200($value)) { return null; }
	return $value["votes"];
}


// Vote (either +1, -1, or 0)
function ApiThemeListVoteSet(&$user, $themelist_id, $vote)
{
	$votetype = [ -1 => "no", 0 => "maybe", 1 => "yes" ];
	$type = $votetype[$vote];
	$value = LdApi::Get("vx/theme/list/vote/$type/$themelist_id", $user);
	if(!ResponseIs200($value)) { return null; }
	return $value["id"]; // Vote ID. Not that it matters.
}

function ApiGradeAdd(&$user, $node, $grade, $score)
{
	$value = LdApi::Get("vx/grade/add/$node/$grade/$score", $user);
	if(!ResponseIs200($value)) { return null; }
	return $value["id"]; // Vote ID. Not that it matters.
}

function ApiGradeRemove(&$user, $node, $grade)
{
	$value = LdApi::Get("vx/grade/remove/$node/$grade", $user);
	if(!ResponseIs200($value)) { return null; }
	return $value["changed"];
}

function ApiGradeGetmy(&$user, $node)
{
	$value = LdApi::Get("vx/grade/getmy/$node", $user);
	if(!ResponseIs200($value)) { return null; }
	return $value["grade"]; // Vote ID. Not that it matters.
}


function ResponseIs200($response)
{
	if($response != null)
	{
		return $response["response_httpcode"] == "200"; 
	}
	return false;
}

function ResponseIs201($response)
{
	if($response != null)
	{
		return $response["response_httpcode"] == "201"; 
	}
	return false;
}

////
//// Low level helper / generation code
////

function GenerateRandomUsername()
{
	global $usewikitext;
	if($usewikitext)
	{
		// glue a few alphanumeric words together
		$length = random_int(3, 15);
		$maxlength = $length+5;
		$username = "";
		while(strlen($username) < $length)
		{
			$word = MarkovRandomWord();
			$safeword = preg_replace("/[^a-zA-Z0-9]/","",$word);
			$username .= $safeword;
		}
		if(strlen($username) > $maxlength)
		{
			$username = substr($username,0,$maxlength);
		}
		return $username;
	}

  $length = random_int(2, 10);
  return bin2hex(random_bytes($length));
}

function GenerateRandomPassword()
{
  $length = random_int(5, 10);
  return bin2hex(random_bytes($length));
}

function GenerateRandomPostTitle()
{
	return GenerateRandomPhrase(2,7);
}

// Future: something much more meaningful. Also figure out how to include image uploads, links, other fun features.
function GenerateRandomPostText($maxParagraphs = 3)
{
	global $usewikitext;
	if($usewikitext)
	{
		$paragraphs = random_int(1,$maxParagraphs);
		$output = "";
		for($p =0;$p<$paragraphs;$p++)
		{
			$sentences = random_int(1,10);
			for($s=0;$s<$sentences;$s++)
			{
				$output .= GenerateRandomPhrase(3,17) . ". ";
			}
			$output .= "\n\n";
		}
		return $output;
	}

}

function GenerateRandomPhrase($minWords, $maxWords)
{
	global $usewikitext;
	if($usewikitext)
	{
		return MarkovRandomPhrase($minWords, $maxWords);		
	}
	
	$words = random_int($minWords, $maxWords);
	$allwords = array();
	for($i=0;$i<$words;$i++)
	{
		$wordlength = random_int(1,5);
		$word = bin2hex(random_bytes($wordlength));
		$allwords[] = $word;
	}
	return implode(" ",$allwords);
}

////
//// Fetch some random wikipedia articles to seed the Markov text generation system
////

function SetupTextGeneration($articles = 10)
{
	MarkovReset();
	for($i=0; $i < $articles; $i++)
	{
		AddWikipediaText();
	}
	
	// Export markov data to file (mostly for examination)
	$f = OpenMarkovFile();
	MarkovExport($f);
	fclose($f);
}

function AddWikipediaText()
{
	// Fetch a random wikipedia article.
	$data = LdApi::GetRaw("https://en.wikipedia.org/wiki/Special:Random");

	$f = OpenWikiDataFile();
	fprintf($f,"%s",$data);
	fclose($f);
	
	// Determine what article we got from the page- class in the body tag.
	if(preg_match('/<body[^>]*page-([^\s]+) [^>]+>/', $data, $matches))
	{
		Message("Reading Wikipedia Article " . $matches[1]);
	}
	else
	{
		ReportError("Wikipedia data seems wrong. Please check.");
		return;
	}
	
	// Get data between '<div class="mw-parser-output">' and '<div class="printfooter">'
	$parts1 = explode('<div class="mw-parser-output">', $data, 2);
	if(count($parts1) != 2) { ReportError("Error in parsing wikipedia page"); return; }
	$parts2 = explode('<div class="printfooter">',$parts1[1], 2);
	if(count($parts2) != 2) { ReportError("Error in parsing wikipedia page"); return; }
	
	// Remove all html tags and [#] references. Remove quotation marks. Remove commas.
	$content = preg_replace('/<[^>]+>/','',$parts2[0]);
	$content = preg_replace('/\[\d+\]/','',$content);
	$content = str_replace('"','',$content);
	$content = str_replace(',','',$content);
	
	// Split on period and newline, eliminate duplicate spaces
	$content = str_replace('.',"\n",$content);
	
	$statements = explode("\n",$content);
	MarkovTrain($statements);
}


////
//// Generate text using markov chains derived from whatever source material you give it.
//// (Well semi-markov, it doesn't really care about the statistical element, just the chains of sequential words.)
////


function MarkovReset()
{
	$GLOBALS["MarkovData"] = [ "Words"=>[], "WordMap"=>[], "Chain2"=>[], "Chain3"=>[], "Stats"=>["UseChain3"=>0, "UseChain2"=>0, "UseRandom"=>0]];
}

function MarkovExport($f)
{
	MarkovEnsureWords();
	fprintf($f, "# Words\n");
	fprintf($f, "%s", implode(",",$GLOBALS["MarkovData"]["Words"]) . "\n");
	fprintf($f, "# Chain2\n");
	$keys = array_keys($GLOBALS["MarkovData"]["Chain2"]);
	sort($keys);
	foreach($keys as $k)
	{
		$values = array_keys($GLOBALS["MarkovData"]["Chain2"][$k]);
		sort($values);
		fprintf($f, "%s", $k ."," . implode(",",$values) . "\n");
	}
	fprintf($f, "# Chain3\n");
	$keys = array_keys($GLOBALS["MarkovData"]["Chain3"]);
	sort($keys);
	foreach($keys as $k)
	{
		$values = array_keys($GLOBALS["MarkovData"]["Chain3"][$k]);
		sort($values);
		fprintf($f, "%s", $k ."," . implode(",",$values) . "\n");
	}	
}

function MarkovTrain($statementarray)
{
	foreach($statementarray as $statement)
	{
		$statement = trim($statement);
		if($statement == "") { continue; }
		$words = preg_split('/[\s,]+/', $statement);
		MarkovTrainWordArray($words);
	}
}

function MarkovTrainWordArray($words)
{
	global $MarkovData;

	$prev1 = "";
	$prev2 = "";	
	$words[] = ""; // Add an empty value to the chains to indicate natural places where the generation can stop.
	foreach($words as $word)
	{
		$key3 = "$prev2-$prev1";
		$key2 = $prev1;
	
		// Add word to word list
		if($word != "") {
			if(key_exists($word, $MarkovData["WordMap"])) { $MarkovData["WordMap"][$word]++; } else { $MarkovData["WordMap"][$word] = 1; }
		}
		
		// Add to 2-chain
		if(!key_exists($key2, $MarkovData["Chain2"])) { 
			$MarkovData["Chain2"][$key2] = [];
		}
		$MarkovData["Chain2"][$key2][$word] = true;
				
		// Add to 3-chain
		if(!key_exists($key3, $MarkovData["Chain3"])) { 
			$MarkovData["Chain3"][$key3] = [];
		}
		$MarkovData["Chain3"][$key3][$word] = true;
		
		
		$prev2 = $prev1;
		$prev1 = $word;
	}
	$MarkovData["Words"] = null; // Word list needs to be rebuilt.
}

function MarkovEnsureWords()
{
	if(!$GLOBALS["MarkovData"]["Words"])
	{
		$GLOBALS["MarkovData"]["Words"] = array_keys($GLOBALS["MarkovData"]["WordMap"]);
		sort($GLOBALS["MarkovData"]["Words"]);
	}
}

function MarkovRandomWord()
{
	MarkovEnsureWords();
	global $MarkovData;
	$index = random_int(1,count($MarkovData["Words"]))-1;
	return $MarkovData["Words"][$index];
}

function MarkovRandomPhrase($minwords = 3, $maxwords = 25)
{
	global $MarkovData;
	MarkovEnsureWords();

	$makewords = random_int($minwords, $maxwords);

	$prev2 = "";
	$prev1 = MarkovRandomWord();
	$words = [$prev1];
	
	for($i=1;$i<$makewords;$i++)
	{
		// Try to generate a new word from markov-3, if we can't, try markov-2, then just a random word.
		$key3 = "$prev2-$prev1";
		$key2 = $prev1;
		
		$word = "";
		if(key_exists($key3, $MarkovData["Chain3"]))
		{
			// Pick a random option
			$options = array_keys($MarkovData["Chain3"][$key3]);
			$index = random_int(1,count($options))-1;
			$word = $options[$index];
		}
		
		// If we don't have a word, try to generate from markov-2
		if($word == "" && key_exists($key2, $MarkovData["Chain2"]))
		{
			$options = array_keys($MarkovData["Chain2"][$key2]);
			$index = random_int(1,count($options))-1;
			$word = $options[$index];
		}
		
		if($word == "")
		{
			$word = MarkovRandomWord();
		}
		
		$words[] = $word;
		$prev2 = $prev1;
		$prev1 = $word;
	}

	return implode(" ",$words);
}


////
//// Low level API interface code
////

class LdApi
{
	static $debug_api = false;

	static $lastRequestLog = null;
	static $lastResponseLog = null;

	public static function PrintLastRequestResponse()
	{
		print( "\x1b[31mLast Request/Response:\x1b[m\n"); 
		print( "\x1b[31m" . LdApi::$lastRequestLog . "\x1b[m\n"); 
		print( "\x1b[31m" . LdApi::$lastResponseLog . "\x1b[m\n"); 
		
		// Also put these in the error log for easier reference.
		LogErr("Last Request/Response:\n");
		LogErr(LdApi::$lastRequestLog . "\n");
		LogErr(LdApi::$lastResponseLog . "\n");
	}

	static function DebugRequestLog($log)
	{
		if(LdApi::$debug_api)
		{
			Verbose($log);
		}
		else
		{
			VerboseHidden($log);
		}		
		LdApi::$lastRequestLog = $log;
	}
	static function DebugResponseLog($log)
	{
		if(LdApi::$debug_api)
		{
			Verbose($log);
		}
		else
		{
			VerboseHidden($log);
		}		
		LdApi::$lastResponseLog = $log;	
	}

	static function SetRequestUser($curl, &$user)
	{
		if($user != null)
		{
			// Generate cookie string for user and set it.
			$cookies = [];
			foreach($user["cookies"] as $c => $v)
			{
				$cookies[] = $c."=".$v;
			}
			$cookiestring = implode("; ", $cookies);
			curl_setopt($curl, CURLOPT_COOKIE, $cookiestring);
			if($cookiestring != "")
			{
				// debug debug Verbose("Sending Cookie: ".$cookiestring);
			}
		}
	}
	static function UpdateUserCookie($headers, &$user)
	{
		if($user != null)
		{
			$lines = explode("\r\n", $headers);
			foreach($lines as $v)
			{
				$parts = explode(": ",$v, 2);
				if($parts[0] == "Set-Cookie")
				{
					// debug debug Verbose("Receive Set-Cookie: ".$parts[1]);
					
					$c = explode(";", $parts[1]);
					$cookiedata = explode("=",$c[0],2);
					// interpret "=deleted" as the condition to delete a cookie, as the code to check the expires time is annoying in php.
					if($cookiedata[1] == "deleted")
					{
						unset($user["cookies"][$cookiedata[0]]);
					}
					else
					{
						$user["cookies"][$cookiedata[0]] = $cookiedata[1];
					}
				}			
			}
		}
	}
	static function ForUser(&$user)
	{
		if($user != null)
		{
			return " for user " . $user["username"];
		}
		return "";
	}
  
	public static function GetRaw($url)
	{

		$c = curl_init($url);
		
		curl_setopt($c, CURLOPT_HEADER, false);		
		curl_setopt($c, CURLOPT_FOLLOWLOCATION, true);		
		curl_setopt($c, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($c, CURLOPT_HTTPGET, true);

		$result = curl_exec($c);
		$success = !($result === false);

		if(!$success)
		{
			ReportError("Error getting '".$url ."' - " . curl_error($c));
		}
		

		curl_close($c);
		
		return $result;
	}  
  
	public static function Get($url, &$user = NULL, $report_error=true)
	{
		global $apibase;
		$outputObject = NULL;
		$urlpath = $url;
		$url = $apibase . $url;
		
		LdApi::DebugRequestLog("GET '".$url."'".LdApi::ForUser($user));
		
		// Add "debug" get request
		if(false === strpos($url,"?")) { $url .= "?debug"; } else { $url .= "&debug"; }		
		
		$c = curl_init($url);
		
		curl_setopt($c, CURLOPT_HEADER, true);		
		curl_setopt($c, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($c, CURLOPT_HTTPGET, true);
		
		LdApi::SetRequestUser($c, $user);
		
		$content = "";
		$result = curl_exec($c);
		$success = !($result === false);
		if($success)
		{
			$parts = explode("\r\n\r\n",$result);
			while($parts[0] == "HTTP/1.1 100 Continue") { array_shift($parts); }
			$headers = $parts[0];
			$content = $parts[1];
		
			$outputObject = json_decode($content, true);
			$httpcode = curl_getinfo($c, CURLINFO_HTTP_CODE);
			$outputObject["response_httpcode"] = $httpcode;			
			
			stats_accumulate("GET", $urlpath, null, $outputObject, $user);
			
			LdApi::UpdateUserCookie($headers, $user);
		}
		if(!$success && $report_error)
		{
			ReportError("Error getting '".$url ."'". LdApi::ForUser($user). " - " . curl_error($c));
		}
		
		LdApi::DebugResponseLog("Response '" . $content . "'");
		if(substr($content,0,4) == "HTTP")
		{
			Verbose("Debug: '" . $result);
		}			

		curl_close($c);
		
		return $outputObject;
	}
	public static function Post($url, $postdata, &$user = NULL)
	{
		global $apibase;

		$outputObject = NULL;
		$urlpath = $url;
		$url = $apibase . $url;		
		
		LdApi::DebugRequestLog("POST '".$url."' with data '".$postdata."'".LdApi::ForUser($user));
		
		// Add "debug" get request
		if(false === strpos($url,"?")) { $url .= "?debug"; } else { $url .= "&debug"; }		
		
		$c = curl_init($url);
		
		curl_setopt($c, CURLOPT_HEADER, true);
		curl_setopt($c, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($c, CURLOPT_POST, true);
		curl_setopt($c, CURLOPT_POSTFIELDS, $postdata);
		
		LdApi::SetRequestUser($c, $user);
		
		$content = "";
		$result = curl_exec($c);
		$success = !($result === false);
		if($success)
		{
			$parts = explode("\r\n\r\n",$result);
			while($parts[0] == "HTTP/1.1 100 Continue") { array_shift($parts); }
			$headers = $parts[0];
			$content = $parts[1];
		
			$outputObject = json_decode($content, true);
			$httpcode = curl_getinfo($c, CURLINFO_HTTP_CODE);
			$outputObject["response_httpcode"] = $httpcode;
			
			stats_accumulate("POST",$urlpath, $postdata, $outputObject, $user);
			
			LdApi::UpdateUserCookie($headers, $user);
		}
		if(!$success && $report_error)
		{
			ReportError("Error getting '".$url ."'". LdApi::ForUser($user) . " - " . curl_error($c));
		}
		
		LdApi::DebugResponseLog("Response '" . $content . "'");
		if(substr($content,0,4) == "HTTP")
		{
			Verbose("Debug: '" . $result);
		}

		curl_close($c);
		return $outputObject;	
	
	}
}

////
//// Statistical tracking for API information
//// * Keep track of most expensive API requests overall and by type of API request. (to granularity of 2 levels, /vx/aaa/bbb)
//// * Keep track of most expensive DB queries overall and by type of API request.
////



function stats_init()
{
	$GLOBALS["stats_api"] = stats_makenode();
	$GLOBALS["stats_db"] = stats_makenode();
	$GLOBALS["stats_dbconnect"] = stats_makenode();
}

function stats_accumulate($type, $url, $postdata, &$response, &$user)
{
	$statsobj = ["type"=>$type, "path"=>$url, "response"=> $response, "username" => $user["username"], "time" => $response["debug"]["request_time"] ];

	$url = substr($url, 3); // skip vx/ prefix
	$parts = explode("/",$url,3);
	$statspath = array_merge([$type], array_slice($parts,0,2));

	stats_accumulateobject("stats_api", $statsobj, $statspath);

	// For each DB request in the response, also make an entry

	unset($statsobj["response"]["debug"]); // Avoid storing / printing out entire DB debug path for every DB response.
	
	foreach($response["debug"]["db_details"] as $detail)
	{
		if($detail["action"] == "query")
		{
			$detail["context"] = $statsobj;
			stats_accumulateobject("stats_db", $detail, $statspath);
		}
		if($detail["action"] == "connect")
		{
			// Also track DB connect stats, but only in a root node. It's not going to be affected by other factors.
			stats_accumulateobject("stats_dbconnect",$detail,[]);
		}
	}

}

function stats_makenode()
{
	return [ "count"=>0, "time"=>0.0, "maxtime" => null, "mintime" => null, "top"=>[], "children" => [] ];
}
// Stats $obj will have at least a "time" element, which will be used to keep track of top stats objects and 
function stats_accumulateobject($var, &$obj, $path)
{
	$target = &$GLOBALS[$var];
	stats_adddata($target, $obj);
	foreach($path as $pathelement)
	{
		if(!key_exists($pathelement, $target["children"]))
		{
			$target["children"][$pathelement] = stats_makenode();
		}
		$target = &$target["children"][$pathelement];
		stats_adddata($target, $obj);
	}
}
function stats_adddata(&$target, &$obj)
{
	$target["count"]++;
	$target["time"] += $obj["time"];
	if($target["maxtime"] === null) $target["maxtime"] = $obj["time"]; else $target["maxtime"] = max($target["maxtime"],$obj["time"]);
	if($target["mintime"] === null) $target["mintime"] = $obj["time"]; else $target["mintime"] = min($target["mintime"],$obj["time"]);
	
	if(count($target["top"]) < TOP_STATS || end($target["top"])["time"] < $obj["time"])
	{
		// Merge new object into the array
		$target["top"][] = $obj;
		usort($target["top"], "statobj_sortfunc");
		if(count($target["top"]) > TOP_STATS)
		{
			array_pop($target["top"]);
		}
	}
}

function sign($n)
{
	return $n>0?1:($n<0?-1:0);
}
function statobj_sortfunc($a, $b) // Sort by time descending.
{
	return sign($b["time"]-$a["time"]);
}	

function format_time($t)
{
	if($t >= 2)
	{
		$t = intval(round($t*1000));
		return ($t/1000) . "s";
	}
	else
	{
		$t = intval(round($t*1000*1000));
		return ($t/1000) . "ms";
	}
}

function time_color($t, $basevalue)
{
	$green_time = $basevalue;
	$yellow_time = $basevalue*5;
	$red_time = $basevalue*25;
	
	$rgb = [0,0,0];
	if($t < $green_time)
	{
		$rgb[1] = 1;
	}
	else if($t < $yellow_time)
	{
		// green-yellow
		$v = ($t-$green_time)/($yellow_time-$green_time);
		$rgb[0] = $v;
		$rgb[1] = 1;
	}
	else if($t < $red_time)
	{
		// yellow-red
		$v = ($t-$yellow_time)/($red_time-$yellow_time);
		$rgb[0] = 1;
		$rgb[1] = 1-$v;
	}
	else
	{
		$rgb[0] = 1;
	}
	
	# Setup color
	for($i=0;$i<3;$i++)
	{
		$rgb[$i] = intval(round($rgb[$i] * 80 + 128));
	}
	return "#".bin2hex(pack("CCC",$rgb[0],$rgb[1],$rgb[2]));
}

function dump_stat_node(&$f, &$node, $prefix="root")
{
	$count = $node["count"];
	$time = $node["time"];
	$min = $node["mintime"];
	$max = $node["maxtime"];
	$avg = 0;
	if($count > 0) { $avg = $time / $count; }	

	fwrite($f, ">>>> Stats ($prefix)\n");
	fwrite($f, "  Request count: $count\n");
	fwrite($f, "  Total time on requests: $time s\n");
	fwrite($f, "  Min time: $min s / Avg time: $avg s / Max time: $max s\n");
	fwrite($f, "  Top time-consumers:\n");
	foreach($node["top"] as $topobj)
	{
		fwrite($f, print_r($topobj,true) . "\n\n");
	}
	fwrite($f, "\n");
	
	foreach($node["children"] as $key => $child)
	{
		dump_stat_node( $f, $child, $prefix . " / " . $key );
	}
}

function dump_stat_var(&$f, $var)
{
	dump_stat_node($f, $GLOBALS[$var]);
}


function dump_stat_html_node(&$f, &$node, $prefix="root", $timebasevalue)
{
	$count = $node["count"];
	$time = $node["time"];
	$min = format_time($node["mintime"]);
	$max = format_time($node["maxtime"]);
	$avg = 0;
	if($count > 0) { $avg = format_time($time / $count); }
	$time = format_time($time);
	$color = time_color($node["maxtime"], $timebasevalue);

	$summary = "$prefix - Count: $count, Total Time: $time, Min $min / Avg $avg / Max $max";
	
	$html = <<<HTMLCHUNK
<div class="hierarchy">
  <div class="container">
  <div class="summary" style="background-color:$color" onclick="ShowHideElement(this.parentElement)">$summary</div>
  <div class="collapse" style="display:none">
  <div class="longcontent">
  <pre>	
HTMLCHUNK;
	fwrite($f, $html);

	foreach($node["top"] as $topobj)
	{
		fwrite($f, print_r($topobj,true) . "\n\n");
	}
	fwrite($f, "  </pre></div></div></div>\n");
	
	foreach($node["children"] as $key => $child)
	{
		dump_stat_html_node( $f, $child, $prefix . " / " . $key, $timebasevalue );
	}
	fwrite($f, "</div>\n");	
}

function dump_stat_html_var(&$f, $var)
{
	$node = &$GLOBALS[$var];
	$basevalue = 0.005;
	$count = $node["count"];
	$time = $node["time"];
	if($count > 0) { $basevalue = ($time / $count)/2; }
	dump_stat_html_node($f, $node, "root", $basevalue);
}

function dump_stats()
{
	$f = OpenStatsFile();
	fwrite($f, "\nDB Connect stats:\n");
	dump_stat_var($f, "stats_dbconnect");

	fwrite($f, "\n\n####################\nAPI Access stats:\n");
	dump_stat_var($f, "stats_api");

	fwrite($f, "\n\n####################\nDB Query stats:\n");
	dump_stat_var($f, "stats_db");
	
	fclose($f);
	
	
	
	// Also generate HTML report
	
	global $event_name;
	
	$f = OpenHtmlStatsFile();
	$html = <<<HTMLSTART
<html>
<head><title>Performance stats for $event_name</title></head>
<body>
<script>
function ShowHideElement(value)
{
	var children = value.getElementsByClassName('collapse');
	var element = children[0];
	if(element.style.display == 'none')
	{
		element.style.display = 'inline';
	}
	else
	{
		element.style.display = 'none';
	}
}
</script>
<style>
div.hierarchy { padding-left:20px; }
div.container { }
div.summary { margin:5px; padding:10px; background-color:#CCC }
div.longcontent { margin:5px; padding:10px; background-color:#aaa }
</style>

HTMLSTART;

	fwrite($f,  $html);

	fwrite($f, "\n<h1>DB Connect stats:</h1>\n");
	dump_stat_html_var($f, "stats_dbconnect");

	fwrite($f, "\n<h1>API Access stats:</h1>\n");
	dump_stat_html_var($f, "stats_api");

	fwrite($f, "\n<h1>DB Query stats:</h1>\n");
	dump_stat_html_var($f, "stats_db");


	fwrite($f, "</body></html>\n");
	fclose($f);
}

dump_stats();

CloseLogs();
exit(0);